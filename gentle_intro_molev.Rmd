---
title: "An extra gentle introduction to molecular evolution"
author: "Stephanie J. Spielman"
site: bookdown::bookdown_site
documentclass: book
output:
  bookdown::gitbook: default
github-repo: sjspielman/molev_intro
# Forthcoming.. 
#bibliography: "bibliography.bib"
#biblio-style: "apalike"
#link-citations: true
#cover-image: cover.png
---



# Introduction

**A WORK IN PROGRESS.** This document is temporary to organize the book, then will be split up into chapters with an associated `index.Rmd`.

With apologies to Bayesians, analyses is ML-focused. This book is geared towards my students. Read and use at your peril if you are not my student.

This considers only **genic evolution.** Intergenic or non-coding DNA also for sure evolves, but this tutorial/background focuses specifically on proteins and their coding regions. 

**This is an area of active research.** By definition this cannot be a comprehensive and fully up-to-date document. This will orient you to the background so that we can learn the active research together.

# Background: Molecular Evolution

Molecular evolution is the field of biology that studies how DNA and protein sequences evolve over long time scales, aka *phylogenetic* timescales. You can think of it as "molecular macroevolution" - the evolution of DNA/protein at the level of species. It's "sister field" is Population Genetics ("popgen"), which is concerned with genetic change *within* species and populations. You may remember the "Allele A1" (or evolfoRces in my section!) simulations from "Introduction to Evolution" - this was population genetics. It considers how interacting forces of mutation, selection, migration, random genetic drift, recombination in sexual species, etc. shape the genetics of populations. Molecular evolution is more of a birds-eye-view of these processes. 

### Evolution in populations

At the level of populations, we generally consider evolution as a process where: a) a random mutation occurs, and b) evolutionary forces act on the mutation. Over generations, one of several things will happen to this mutation:

+ It will take over the population so that all individuals have it, aka it *fixes*, or *goes to fixation* in the population. We refer to fixed mutations as **substitutions.** This can happen either due to strong **positive selection** (selection really favors it!), or genetic drift (even mutations that are *beneficial* can fix in small populations where drift is strong enough). 
+ It will be lost from the population and no individuals will have it. From a birds-eye-view, then, it's as though this mutation never even happened (keep this in mind!!). Mutations can be lost either due to **negative selection** (selection really does not like it), or it can be randomly lost due to genetic drift even if it's not *deleterious*.

While this process of either fixation or loss takes places, we would say that the mutation is **segregating in the population.** This means that some individuals will have it, and others will not (so it's at some intermediate frequency), representing a **polymorphism.** If natural selection is *not* acting on the mutation (aka its fitness is "neutral"), or selection is acting *so weakly* that we can just as easily ignore it, we might describe the mutation as "drifting" through the population. Its frequency fluctuates over generations in the population just by chance. Again, given *enough* time, though, this mutation will eventually fix or be lost.

When we take a phylogenetics or molecular evolution-oriented view of this process, mutations that are lost won't make the cut - we only see mutations that end up fixing, aka **substitutions.** The figure below displays this outlook: On the left, we see a population of 7 dots. This population experiences mutations (red --> blue for example), and some of these mutations fix while others are lost from the population. Zooming out of this process, we arrive at the right-side image. At a broad level, the *entire population* could be described as red -> blue -> orange. Green and purple were just blips on the radar that aren't part of the long-term evolutionary process. 

### Evolution in DNA

What is a mutation? It is a *random* (aka, not guided by a "need" for that mutation) mistake made during DNA replication. Those mutations that occur in the *germ line* (gametes: egg and sperm cells) are those that are relevant for evolution, since they can be passed on to the next generation. *Somatic mutations*, mutations which occur in literally any other cell of your body, happen regularly but usually are not a major issue. However, if enough somatic mutations occur in the "right" genes, this leads to cancer. 

Broadly speaking, there are **three** kinds of mutations to think about at the molecular level. 

+ The wrong nucleotide is used during DNA replication, which ultimately changes the nucleotide. If this mutation fixes (and that's all we care about!), we call it a **substitution.** Therefore, in phylogenetics, we actually refer to nucleotide changes as a whole as **substitutions.** Due to redundancy in the genetic code (there are multiple codons for most amino acids), there are several different consequences when a nucleotide is changed within a *protein-coding region* (aka exons, not introns) of the genome:
  + A *missense* mutation also affects the translated protein product - the nucleotide mutation causes a change in the amino acid sequence. In evolutionary biology, **we call this a nonsynonymous mutation**.
  + A *silent* mutation does not affect the translated protein product.  **We call this a synonymous mutation**.
  + A *nonsense* mutation creates a premature stop codon, and totally messes up the protein product. **We generally "ignore" nonsense mutations over long evolutionary periods.** What allows us to do this? Most of the time if you introduce a stop codon, the protein isn't going to work, which usually means the individual who has that mutation has *really low fitness* (if even viable in the first place)! They won't have offspring, and they won't therefore be part of the evolutionary trajectory of the population. Therefore, over long time scales, we won't even observe these types of mutations.
+ Extra nucleotides are added during replication. This is called an **insertion** - some DNA is inserted. Similarly, some nucleotides can accidentally get skipped during replication. This is called a **deletion** - some DNA is deleted. Together, we refer to insertions and deletions as **indels** (pronounced like "incels" but with a "d", sorry for the terrible reference point). Of course, when indels occur, there is going to be some kind of change to the final translated protein sequence. 

There is a related vocabulary term to introduce at this time: **S**ingle **N**ucleotide **P**olymorphism, called SNPs ("snips"). Note that evolutionary biologists tend to favor this term, but other fields like medical genomics might called it an "SNV" (pronounced as the letters S-N-V) for single nucleotide **v**arient. A SNP is a type of polymorphism (different individuals in a *population* have different allele versions - nothing is fixed!!) that occurs at a *single* nucleotide. They are very commonly-studied type of variation within populations. From the birds-eye-view of phylogenetics, we generally "ignore" SNPs since we only are considering fixed mutations. (But should we? Unclear! Is it really bad to ignore these? In certain circumstances, maybe!! This is something I'd like to study!) 



# Background: Interpreting, building, and using phylogenies



## Reading and interpreting phylogenies

Include an image of a tree, a link to the tree-thinking, and a link to Kahn academy. 


**TODO: Where will we cover evolutionary distance?**



## The pipeline of phylogenetic reconstruction

Building trees: This is a complex field that you could get an entire degree in, at least. Over the years there have been many proposed routes:
1) distance-based. many types here. clustering methods like UPGMA, NJ. Minimum evolution.
2) parsimony. can be complex with more rules like types of changes are assigned different weights. directional mutations, etc.
3) model-based reconstruction. **This is where we live.** Introduce probabilities, likelihood, bayesian, concepts of heuristics and treespace.

Introduce back-mutations, parallel, etc here as a partial justification for why we use model-based.

## Analyzing sequences in a phylogenetic context

Once we have a tree, we can also use it for further model-based studies. We can ask....
1) molecular clock analyses?
2) rate of evolution?
3) relationship between other traits and tree?


## Gene tree vs species trees

They are NOT the same. In this lab we focus on gene trees since we are studying gene evolution.


# Mutiple sequence alignments

Recall from the earlier section [Evolution in DNA], that DNA mutations fall into two broad categories: a) substitutions (change in existing nucleotide(s)), and b) indels (nucleotides are inserted or deleted). In order to compare homologous sequences to one another, however, we need to line them up so they match. However, because of indels, two homologs are not necessarily going to have the same number of nucleotides. Some sequences will be shorter or longer, and sometimes *by a lot*.^[What's *really* interesting though is that even though protein sequences and lengths change over evolutionary time, their overall *structure* really does not. Natural selection imposes strong constraints on protein evolution to maintain a particular structure, which in turn allows the protein to properly function]. 

We therefore need to create something called a *sequence alignment* (a "character matrix," which you may recall from "Introduction to Evolution", but for DNA and protein sequences instead of physical traits). When you align two sequences together, it's called a "pairwise alignment." When there are three or more sequences (pretty much all modern-day evolutionary studies), it's called a **multiple sequence alignment**, often abbreviated as "MSA" and simply referred to as "alignments"^[CAUTION: There is another type of "alignment" in bioinformatics that is used for genome sequencing. The type of alignment we are concerned with is those that compare *homologous sequences from DIFFERENT individuals/species*.] There are many different software programs which will align your homologous sequences. In the end, sequences will have both nucleotides (or amino acids, depending on your dataset), and **gaps**, represented as dashes ("-"), which represent indel events. Each **site** is a **column** in the alignment.

**MSAs are _hard_ to make. Really, really hard.** So hard in fact, that we are pretty sure that even the fanciest most computer-y algorithms for building MSAs are error prone. The problem is, the software doesn't know about the evolutionary process itself and instead relies on mathematical optimization to get the "right" alignment. As a consequence, we are pretty sure a lot of alignments are wrong, but we also don't know *in what way* they are wrong. To make matters worse, MSAs are **THE** fundamental unit of data used in *all comparative sequence analyses and phylogenetics.*

Because alignments are known to be error-prone, a lot of people (including myself) have tried think about ways we can quantify this uncertainty, or at least identify unreliable regions in a given MSA. Some people advocate for strategies like *trimming* or *filtering* alignments, where you remove parts of the alignment you infer to be problematic. Usually, these are regions that are really "gappy" (yes, we really use this word!). Indels are what makes aligning so tricky - indeed, if there were no indels and only substitutions, all homologous sequences would already be the same length and directly line up into columns in the first place. There has been conflicting evidence over the years whether filtering improves or worsens analysis outcomes. It doesn't seem to hurt, but it also doesn't seem to help very much.



# Evolutionary models

We are in statistics world now which means everything is probabilities. What is the prob of mutation a -> c? c-> t? what about if we consider data at the protein level? prob tryp -> tyro?

Having a set of probabilities for these types of changes over time is our evolutionary model. Specifically, we use a framework called Markov. 

Introduce the word *parameter* as variable. Introduce the word *estimate* as it differs from parameter.

## Background: Markov models and chains

Weather example of rain/sunshine from bayesian class and show an example of a chain.

Then an example of a chain with DNA.

Memoryless, which lines up nicely with how we think evolution works.

We often use "time-reversible" which means DNA evolution

## Flavors (DNA, protein, codon) and applications

## Phenomenological vs mechanistic

## Origins: distance stuff from dayhoff and JC69

## Choosing a model
This is a broader concept in statistics: How do I choose a model for my data? What variables should I include, aka what level of complexity? We want to find the middle ground in under/overfitting and deal with the precision/bias tradeoff. 

Relative vs absolute.
Relative says: I have a measure of "goodness-of-fit" and a family of candidate models I could use. We can rank them relative to one another.
Absolute says: How well does this model recapitulate trends in my data? Also referred to as tests of model adequacy. DOes the model adequately describe my data?


Finally the adage "All models are wrong but some are useful" and other useful Boxisms. Remember we are never going to actually model reality. 


# Building your phylogeny

Introduce likelihood, bayesian for appeasement purposes.

Caveats for math and computers running in a reasonable amount of time:
+ we consider each site as evolving independently. this is obviously crap.
+ we also consider the process time-reversible. This is very likely to be crap.

# Assessing confidence in phylogenetic inferences

Confidence measures exist *under the assumption* of the model used. Therefore they never represent "is this node right?" They represent "how well is my node supported under this given model of evolution?" It is support, or lack of support, towards each node which itself is a hypothesis under the model.  

## Bootstrap and friends

We'd like more data to assess confidence, but we are stuck with the dataset we have. Booo. We use this concept sampling-with-replacement
to do a bootstrap, so-called due to phrase "pull yourself up by bootstraps" - assess your confidence with the data you already got. In the MSA context, a given COLUMN is the unit of data for building the tree. So we make X new bootstrapped alignments, and build a tree under the model, and ask: In how many of those X trees is this split present? That is the bootstrap. 100 is common but with fancy schmancy computers 1000 has gotten more common. $\geq70$ considered to be reliable.

There are other similar measures that have been developed over the years and literally are currently being developed.


## PP

Unlike ML where a single tree is spit out, bayesian gives you a distribution of trees from which a so-called "posterior probability" of observing that node can be deduced. These range from 0-1. 

They may however be totally borked - a lot of recent research has suggested that PP's are inflated and way too high for spurious nodes and give some false security. 


# Measuring evolutionary rates

This is an example of an analysis we can do once we have a tree.

## Nucleotide and protein relative rates

## Codon $dN/dS$ 

## Mutation-selection models

# The Molecular Clock and the Neutral Theory of Molecular Evolution

I immediately regret templating out this section.

